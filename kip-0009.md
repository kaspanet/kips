```
  KIP: 9
  Layer: Mempool, P2P, Consensus
  Title: Extended mass formula for dust prevention
  Authors: Michael Sutton <msutton@cs.huji.ac.il>
           Ori Newman <orinewman1@gmail.com>
           Shai Wyborski <shai.wyborski@mail.huji.ac.il>
           Yonatan Sompolinsky
  Status: proposed, implemented in testnet 11 ([PR](https://github.com/kaspanet/rusty-kaspa/pull/379))
```

# Motivation
A few months back, the Kaspa network has faced a dust attack which exploited the high block-DAG capacity in order to increase the storage required for a full node (for a detailed account of this attack on Kaspa see [1]). A mempool patch [2] was applied to counter the attack by aggressively throttling transactions with more outputs than inputs. However, this patch did not properly address the quality-of-service (QoS) required for ordinary users making ordinary transactions, which often might contain excessive outputs (e.g. due to having a *change* output). Essentially, the patch harmed the scalability and throughput of the network by only allowing a single such transaction in each block. In this document we propose a comprehensive approach that balances the ostensibly contradictory objectives of preventing storage bloat without affecting the QoS.

Our proposal is based on a research paper written by authors of this document [3]. A draft of this paper with full analysis and proofs supporting the claims brought here exists but isn't published yet (as of writing this document). In this document we will focus on the concrete formula suggested and its practical implications, both on security and usability.  

# Proposal
Blocks in the Kaspa block-DAG have a mass limit of 500,000. The mass of a block is the sum of the mass of all transactions it contains. In the current transaction mass formula, different types of data have different mass costs. For instance, signatures have a relatively high mass per byte compared with other data since verifying them is computationally expansive. However, current costs mostly address temporal usage of resources such as computation and short-term transaction storage (since transactions are eventually pruned), but they fail to address the long-term effect on state storage, i.e., the direct or indirect consequences of a transaction on the number of entries in the UTXO set. 

Identifying this effect *locally* is no easy task -- for instance, a transaction can have 2 inputs and 2 unevenly distributed outputs (1 being “dust”), thus seemingly not increasing the size of the UTXO set, however the UTXO set now has an entry with hardly no intrinsic value, while the other large entry can be used for further state fragmentation in the future. At the same time, charging high costs per transaction by observing only the locally-visible increase in state size cannot capture the *global* structure of an ongoing attack and inevitably ends with a tradeoff that either harms everyday users or does not sufficiently prevent the attack. 

### A balanced cost function
Assume a transaction is composed (amongst other fields) from a set of input values $I$ and a set of output values $O$. We propose to add an additional mass component called the `storage_mass` computed in the following way: 
$$\text{storage mass}(tx) = \left(\sum_{out.val  \in  O} \frac{C}{out.val} - \frac{C\cdot|I|^2}{\sum_{in.val \in I} in.val}\right)^+;$$ 
where $C$ is a constant controlling the correlation of inverse KAS value to mass units and $(\cdot)^+$ is a shorthand for $max(\cdot, 0)$. 

A more concise representation of the same formula can be given using the harmonic and arithmetic means ($H, A$ respectively):
$$\text{storage mass}(tx) = C\left(\frac{|O|}{H(O)} - \frac{|I|}{A(I)}\right)^+$$

In essence, the formula is sensitive to the distribution of output values (smoothly penalizing smaller and smaller entries), while balancing this by taking into account the size and value of the input set. As proven in [3], the crucial meaning of this formula is that the overall `storage_mass` required for executing a set of transactions is now lower bounded by a quadratic function of the global state growth it caused. More formally, assume $G$ is a DAG of transactions resulting in $growth(G)$ UTXO-set growth, and denote $budget(G)$ to be the overall value of initial UTXO entries consumed by $G$, then:
$$\text{storage mass}(G) \ge \frac{C\cdot growth^2(G)}{budget(G)}$$

Below we will explain the meaning of this bound using concrete numbers.

### Combining storage mass with current mass formula
Let us name the current mass calculation already implemented in Kaspa as `compute_mass`. Both quantities, storage and compute masses, represent independent resources, thus we suggest the combined mass calculation to be the maximum over both and not their sum:
$$\text{mass}(tx) = max\left(\text{compute mass}(tx) , \text{ storage mass}(tx)\right)$$ 

### Relaxed storage mass formula
As shown in [3], the storage formula can be relaxed in the special case of 2:2 transactions (2 inputs and 2 outputs). That is, if $|O| \le |I| \le 2$, then:
$$\text{storage mass}^*(tx) = C\left(\frac{|O|}{H(O)} - \frac{|I|}{H(I)}\right)^+$$
The importance of this exception will be explained below when discussing wallet functionality.  

# Analysis of dust attack costs and regulation of UTXO set growth
- fixed budget
- fixed growth rate
- overall growth

# Quality of service and wallet consequences

## Ordinary wallet transactions

## Compounding transactions

## Exchanges and pools

## Micropayments

# References
[1] “A very dusty yom-kippur” https://medium.com/@shai.wyborski/a-very-dusty-yom-kippur-dust-attack-post-mortem-faa11804e37

[2] Kaspad go-lang dust patch: https://github.com/kaspanet/kaspad/pull/2244

[3] Unpublished paper on regulating state growth, this reference will be updated once the paper is published online.
