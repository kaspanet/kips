```
  KIP: 9
  Layer: Mempool, P2P, Consensus
  Title: Extended mass formula for dust prevention
  Authors: Michael Sutton <msutton@cs.huji.ac.il>
           Ori Newman <orinewman1@gmail.com>
           Shai Wyborski <shai.wyborski@mail.huji.ac.il>
           Yonatan Sompolinsky
  Status: proposed, implemented by the rust codebase and applied in testnet 11 
```

We propose a mechanism for regulating the growth rate of the UTXO set in both organic and adversarial settings. Unlike other attempts to mitigate UTXO bloat (accumulators, demmurage, and so on), our proposal requires nothing but a simple change to the logic of how the mass of a transaction is computed. In this proposal, we specify the revised formula and its consequences, and describe how ecosystem software such as wallets, pools, and exchanges should adapt to this change without affecting the quality of service. We provide an intuitive overview of the remarkable properties of the new mass formula, and defer the formal treatment to a soon-to-be-published preprint. However, we stress that all required properties have been formally verified before writing this proposal.

# Motivation
State bloat is a concern all cryptocurrencies are facing. However, in our case there is an additional, more immediate motivation.

A few months ago, the Kaspa network faced a dust attack that exploited the high throughput to create many minuscule UTXO, forever increasing the storage costs of Kaspa nodes. The attack was eventually stopped by deploying a mempool patch [2] (see [1] for a detailed account of the attack in its resolution). While great efforts were made to reduce the consequences of the solution to the network's quality-of-service (QoS), it did impose a limitation on the number of transactions with more outputs than input allowed on each block. Since many standard transactions are of these form (most typically, a transaction with a single input, a destination output, and a change output), this resulted in a noticeable QoS decrease. While the current effect on the quality of service is quite bearable (increasing the delay of such transactions by dozens of seconds at worst), increased adoption will greatly exacerbate this effect, providing ample motivation to expedite the implementation of a sustainable solution.

# Background

### Transaction Mass vs. Fees
The capacity of a block is bounded by *mass*. The difference between mass and size is that different types of data are considered "heavier" or "denser", in the sense that they consume more mass *per byte*. For example, a digital signature of a UTXO used as an input must be *verified*, and since verifying signatures is a computationally costly process, the mass consumed by a digital signature spending an input is much larger than the mass of an address specified in an output, despite both having roughly the same size in kilobytes. For an exact specification of how mass is calculated, see [add ref].

Increasing the mass cost of wasteful transactions is an effective countermeasure to regulating transaction throughput, as it allows us to control how much each block increases the state (to a limited but sufficient extent, as we will soon see). This approach could be considered an adaptable version of imposing high fees on wasteful transactions, with the following benefits:
1. It does not require an estimate of what constitutes a "high" fee. Instead, the fee is naturally monetized as the value of the blockspace consumed by the transaction.
2. It works in the absence of an active fee market. Even if there are no fees, the mass limits regulate the storage increase.

### Quadratic Storage Costs via Local Mass Costs
Our overarching goal is to make the cost of wasting some amount of storage *quadratic* in the amount of the storage wasted. That is, taking up ten times more storage takes 100 times more mass, taking up 100 times more storage takes 10000 times more mass, etc.

For reasons we will not get into right now, it follows that the amount of mass required to waste some amount of storage always decreases linearly with the *budget* of the attack. That is, the amount of kas available to the attacker (regardless of how the kas is divided into UTXOs). If we use *growth* to denote the amount of storage wasted by the attack, the best we can hope for is that the cost of the attack is proportional to $\text{growth}^2/\text{budget}$ (the proportionality constant is a global system parameter we will discuss in detail later).

Designing a mass function providing such quadratic growth is tricky, due to two contrasting desires:
1. Global cost: the cost should be quadratic of the growth *regardless of how the attacker structured his attack*. An attacker can structure his attack in many ways, creating many transactions with intricate dependencies between them, and we must make sure that even the cleverest attacks will ultimately pay a quadratic price.
2. Local computation: the mass of a transaction *must not depend on other transactions*, and must be completely computable just from the data contained in the transaction itself. In particular, our mass formula only depends on the values of the inputs and outputs.

To illustrate why this is tricky, consider attempting the above by setting the mass of a transaction with $I$ inputs and $O$ outputs to be proportional to $(O-I)^2$. While locally it achieves quadratic growth, a clever attacker can increase the size of the UTXO set by $N$ entries by creating $N$ transactions, each with one input and two outputs. The accumulated mass of the attack is linear in $N$ rather than quadratic. In fact, we prove in the research paper that *any* attempt to compute mass based only on the *amount* of inputs and outputs (while ignoring their values) will fail. The reason for this ultimately boils down to the following observation: the mass of a transaction with two outputs of value $V/2$ is the same as that of a transaction (with the same inputs) outputting two inputs of values $\varepsilon V$ and $(1-\varepsilon)V$ for an arbitrarily small $\varepsilon$, and this property can be cleverly abused to cheaply grow the storage.

# Proposal
We propose a new quantity called the `storage_mass`, and refer to the current notion of mass as `compute_mass`. Both notions of mass are crucial -- the former protects the network from storage attacks, while the latter protects it from CPU attacks. Hence, we propose the following total mass formula:$$\text{mass}(tx) = max\left\{\text{compute mass}(tx) , \text{storage mass}(tx)\right\}\text{.}$$
The rest of this section specifies our proposal for defining `storage_mass`.

### A balanced cost function
We model a transaction of two sets of values, the input values $I$ and output values $O$ (strictly speaking $I$ and $O$ are multisets, as the same value can occur several times, but we ignore this technicality here). We use the notation $x^+ = \max\{x,0\}$. The storage mass is defined as follows:

$$\text{storage mass}(tx) = C\cdot\left(\sum_{o  \in  O} \frac{1}{o} - \frac{|I|^2}{\sum_{v \in I} v}\right)^+\text{.}$$
In the formula above, $C$ is a constant to be determined later. $C$ can be roughly thought of as the "conversion rate" between "inverse kaspa" and mass (note that if mass is measured in grams then $C$ has units of grams*kaspa, or grams per "inverse kaspa").

We can rewrite a more "symmetric" version of this formula by introducing the notations $A$ and $H$ for arithmetic and harmonic mean respectively. Namely
$$A\left(I\right)=\frac{1}{\left|I\right|}\sum_{i\in I}i\text{, }\text{ }H\left(O\right)=\left|O\right|/\sum_{o\in O}\frac{1}{o}\text{.}$$

With these notations, the `storage_mass` takes on an arguably more pleasant form:
$$\text{storage mass}(tx) = C\cdot\left(\frac{|O|}{H(O)} - \frac{|I|}{A(I)}\right)^+$$

The idea behind this formula is that a transaction should be *charged* for the storage it requires and *credited* for the storage it frees. However, there is a principal difference between them: the storage charge should reflect how distributed the outputs are, while the credit should only reflect the number of consumed UTXOs and their values. This way, transactions that do not increase the UTXO set much (or even decrease it) but create minuscule inputs are heavily charged, while transactions whose inputs and outputs are on the same order of magnitude will not pay a lot of mass, even if they do increase the UTXO set. This excludes the ability of a storage attack, since such an attack requires breaking large UTXOs into small UTXOs. This is why using the arithmetic mean to credit and the harmonic mean to charge makes sense: The arithmetic mean is the same for any two sets of values of the same size and sum, it completely "forgets" how the values are divided. On the other hand, the harmonic mean is extremely sensitive to how values are divided and becomes very small if the smallest value is very small.

In [3], we formalize this intuition by proving that this definition of `storage_mass` satisfies the "global quadraticity" property described above. A more version of our theorem is as follows: let $T$ be a set of transactions (say, transactions created by an attacker attempting a dust attack), say that there are $R$ UTXOs that are consumed by $T$ (that is, consumed by a transaction in $T$, but not created by any transaction in $T$), and $L$ UTXOs created by $T$ (that is, created by a transaction in $T$, but not consumed by a transaction in $T$). Finally, let `budget` be the sum of values of $I$, then
$$\sum_{\text{tx}\in T}\text{storage mass}\left(tx\right)\ge C\cdot\frac{\left(L-R\right)^{2}}{\text{budget}}\text{.}$$

Below we provide concrete illustrations of the consequences of this bound.

### Relaxed storage mass formula
Consider the following relaxed bound:
$$\text{storage mass}^*(tx) = C\cdot\left(\frac{|O|}{H(O)} - \frac{|I|}{H(I)}\right)^+\text{.}$$

We show in [3] that using `storage_mass*` for transactions satisfying $|I|\le|O|\le 2$ does not violate the bound above.

This relaxation might seem mild, but it actually has important practical implications. In particular, as we explain below, it allows a very simple input-selection logic for wallets.

**Remark**: Some might wonder whether we can apply the relaxation for *any* transaction with $|I|\le |O|$. The answer is that we believe it is, but are unable to prove it, and are convinced that proving it requires a completely different mathematical approach than the one we used. However, it does not make much of a difference, since a transaction with $|I|\le |O|$ can be broken into a small number of transactions with $|I| \le |O| \le 2$ with very small ovehead.

# Security analysis and growth regulation
Let us use some concrete numbers to gain a quantitative understanding of the implications of the quadratic growth bound. We measure kaspa in dworks (recall that a dwork is the smallest unit of kaspa available, and is worth one hundredth of a millionth of a kas). We set $C = 10^12$, and consider an attacker seeking to increase the storage requirements by one gigabyte. For that, they would have to create $20$ million, or $2 \cdot 10^7$ new UTXO entries. We can now ask ourselves two questions: 1. How long would the attack last given a fixed budget? 2. How expensive the attack should be given it should last a fixed amount of time.

- **Fixed budget** Say the attacker has a budget of $20,000$ kas. That is, $2\cdot 10^4\cdot 10^8$ dworks. Plugging this into the bound, we get that $C\cdot growth^2/budget = (10^{12}\cdot 4 \cdot 10^{14})/(2 \cdot 10^4 \cdot 10^8) = 2 \cdot 10^{14}$. That is, the attack would cost $2 \cdot 10^14$ grams, that is, the capacity of 400 million blocks. Hence, in 10BPS such an attack would require at least a year and a half, assuming the attacker uses 100% of the network throughput and the fees are negligible.

- **Fixed growth rate** Say the attacker wishes to increase the storage by a whole GB within a single day (again, assuming the attacker is given the entire network throughput for negligible fees). In 10BPS, the network has a throughput of a bit over $4\cdot 10^{11}$ grams per day. Substituting into the bound and rearranging we get $budget \ge C \cdot growth^2/\text{mass}$. Substituting $C = 10^{12}$, $growth = 2 \cdot 10^7$ and $\text{mass} = 4\cdot 10^{11}$ we get that the required budget is at least $10^{15}/4$ dworks, which is $2.5$ million `KAS`.

Overall, the attack is either very slow, or requires a large budget.

We can also use the bound to provide an absolute worst-case upper bound on the ***organic*** growth of the UTXO set. Assume for simplicity the total circulation is $20$ billion kaspa. With $C=10^{12}$ and assuming the total daily mass is $4\cdot 10^{11}$ (which is very close to the actual daily mass in 10BPS) the bound implies that in $d$ days the storage can increase by at most $460\sqrt{d}$ gigabytes. This allows us to bound the storage increase as a function of the time that passed since the mass policy was implemented. During the first day, the storage can increase by at most one terabyte. During the first year: at most $10$ terabyte. During the first ten years: at most $25$ terabytes. This is a *very* mild growth considering it bounds even the worst scenario possible: all kas holders joining forces to increase the storage as much as possible, managing to apply the best strategy to do so. To get a sense of how mild that is, note that the maximal possible size of the UTXO set (obtained under the scenario that the entire supply is fragmented into $10,000$ dwork UTXOs) is $25$ *peta*bytes.

# Quality of service

We now proceed to discuss the implications of storage mass on common everyday transactions. Consider as a basic benchmark a transaction with a single input of $100$ `KAS` and two near-equal outputs with $\sim 50$ `KAS` each. The storage mass is $\sim 2\cdot C/(50 \cdot 10^8) - C/(100 \cdot 10^8) = 300$. The minimal `compute_mass` for such a transaction is typically at least $2000$ gram, so clearly `storage_mass` has no consequences in this case (due to the max operation used to combine the masses). This illustrates that most everyday uses, even with relatively small `KAS` values, and despite increasing the UTXO-set size, are not affected by the storage formula. More generally, a typical transaction with outputs which are all larger than $\sim 0.1$ `KAS` will result in at most $\sim 100,000$ mass, an amount which still fits under the standard limit per transaction which is $100,000$.

As transaction output values get closer to $0.1$ `KAS`, the storage mass approaches $100,000$ gram. As a result, the standard mempool selection algorithm will give higher priority to transactions with lower mass unless the $fee/mass$ ratio is increased. This means that inclusion of such transactions when the network is congested requires a higher fee for proper quality of service. In section [Wallet algorithm](#wallet-algorithm) we will show how to compose transactions for sending arbitrarily small values (even below $0.1$ `KAS`), and in section [Micropayments](#micropayments) we will discuss strategies for mitigating this cost altogether.


### Compounding transactions
A compounding transaction can be defined as a transaction where $|O| \le |I|$ and the outputs are equally distributed (where typically $|O| = 1$). Since outputs are uniform we have that the storage mass equals $C\left(\frac{|O|}{A(O)} - \frac{|I|}{A(I)}\right)^+$ (the harmonic and arithmetic means are equal for uniform sets). Further evaluation of this expression shows that such transactions imply $0$ storage mass *regardless of the magnitude of output values*. To see this, note that $|O|A(O) \approx |I|A(I)$ unless the fee is extremely high. This phenomena is a result of the negative component in the storage formula where the impact of spent input values outweigh the cost of output values. In general this reflects that the storage mass function is fair and allows transfer of values which are roughly in the same magnitude of `KAS` value with no significant cost.   

### Exchanges and pools
Wallets managed by exchange services typically have an influx of incoming UTXOs (coming from user deposits) which is expectedly equal to the amount and distribution of outgoing UTXOs (resulting from user withdrawals). Tight management of these UTXOs can help minimizing the effect of storage mass even when the Kaspa economy gets to a stage where typical transactions frequently involve sub-`KAS` values.   

Likewise, pools have a flow of UTXO entries coming from coinbase transactions, where the entry amounts are equal to the current block reward. Setting the minimum for miner payout to be equal or greater than the (dynamic) block reward, will suffice to ensure negligible storage mass for pool payouts even when block rewards will have sub-`KAS` value.  

### Micropayments
In the following section we discuss micropayments of extremely small values ($\ll 0.1$ `KAS`). Despite seeming like a long-shot, we see such (future) payments as an important aspect of Kaspa and the economy we strive that would be built over it. We will assume that every user wallet holds at least 1 `KAS` (or $10^8$ dworks).

The hero of our story will be a millionaire owning more than $10^{10}$ dworks. This millionaire loves buying his daily ice-cream from the nearby Kaspa-accepting store which charges the remarkable price of $10^4$ dworks per ice-cream ($0.0001$ `KAS`). Using a standard transaction with one payment output and one change output will result in mass which is way above the limit of an entire block. The key point is in realizing that the merchant selling the ice-cream does not keep such small amounts indefinitely but rather will compound them eventually (say on a daily basis). However the future actions of the merchant are unknown to the system and the action is locally indistinguishable from the actions of a deliberate dust attacker. In an account-based model, such a transaction would merely appear as a transfer of a small value between significantly larger accounts. Essentially, the account model combines the future compounding of the payment into the merchants account into the local operation.

We argue that this exact behavior can be emulated also in the UTXO model by creating a mutually signed transaction. The buyer and the seller can mutually create a transaction with an input of, say, $10$ `KAS` from each and an output of $10.0001$ to the seller and $9.9999$ to the buyer, which results in negligible mass. 

The apparent downside to this solution is that the merchant must constantly use a hot wallet and cooperate with the customer to create a transaction signed by both, which is challenging on the UX level. In a separate KIP we will propose special *auto-compounding* wallet addresses, where UTXOs owned by such addresses will allow anyone to add to their balance without the owner of the UTXO having to sign it. The address will be able to define a minimum payment value in order to avoid double-spend spamming by malicious users. Among other applications, this mechanism will remove the need for a hot wallet and will allow creating a mutual transaction without requiring mutual signing.

### Wallet algorithm
In the following we describe a wallet algorithm which allows making any micropayment in the event where the user doesn't care about the excess mass or if a mutual transaction cannot be created. Notably, the algorithm requires using the [relaxed](#relaxed-storage-mass-formula) formula and wouldn't converge without this relaxation. 

Let $M$ be the maximal mass per transaction and denote $F$ to be the standard fee required for a transaction with mass $M$. Assume the user desires to make a payment with value $P$ and that we already collected sufficient inputs $I$ such that $\sum_{v \in I}v \ge P + F$. Furthermore, assume that $P \gg F$ (otherwise it might not be worth making this payment altogether). The algorithm assumes that a transaction composed of $I$ and $O = \lbrace P, \sum_{v \in I}v - P - F\rbrace$ has $\text{compute mass} \le M$ but $\text{storage mass} > M$. Otherwise, if compute mass is too large, it should be solved using the current methods of compounding by building a transaction tree. Recall that compounding transactions will never have storage mass, so there's never a need to solve both objectives in parallel. Eventually we arrive at a root transaction where compute mass is low enough, at which point storage mass can be dealt with if needed. 

**Single step optimization** We begin by solving a single step of the process. The question we ask is “Given a mass bound $M$ and a set of inputs $I$, what is the minimum payment value possible without surpassing $M$?”. Or in more mathematical terms “What is the maximum asymmetry we can create between the 2 outputs given the constrains?”. Denote $N$ to be the negative component of the storage mass as described by the relaxed formula. Note that $I$ and the number of outputs (which is known to be 2 in this case), are sufficient for calculating this part. Let $T=\sum_{v \in I}v - F$ denote the total outputs value. We need to solve the following equation: $M = C/T\alpha + C/T(1-\alpha) - N$, where $\alpha \in (0, 1)$. Reorganizing terms we get $(M+N)T/C = 1/\alpha + 1/(1-\alpha)$. Let $D = (M+N)T/C$. Reorganizing terms further we arrive at the quadratic equation $D\alpha^2 - D\alpha + 1 = 0$ which solutions for are $\alpha = (D \pm \sqrt{D^2 - 4D})/2D$. Note that from symmetry of $\alpha, (1-\alpha)$ both solutions of the equation essentially give the same answer.

**Iterative process** Using this single step optimization we now describe an iterative algorithm for composing the chain of transactions required for making a micropayment: 

```python
def BuildTxs(inputs, payment):
    txs = []
    while storage_mass(I=inputs, O=[payment, sum(inputs) - payment - F]) > M:
        T = sum(inputs) - F
        N = negative_mass(inputs, 2) 
        D = (M + N)T/C
        alpha = (D - sqrt(D^2 - 4D))/2D                         # single step optimization, taking the smaller solution 
        outputs = [ceiling(alpha * T), T - ceiling(alpha * T)]  # round up in order to not increase the mass above M
        txs.append((inputs, outputs))
        inputs = outputs
    txs.append((inputs, [payment, sum(inputs) - payment - F]))
    return txs
```

**Remarks**
- In all iterations of the while loop (except maybe for the first), $I=O=2$ 
- Without the relaxation which uses the harmonic mean over the inputs (in the 2:2 case), the loop would not converge. The arithmetic averaging done over the inputs would yield the same $N$ value over and over
- In all intermediate transactions built within the loop, the recipient for both outputs should be the change address of the *sender* 
- In the final transaction built, it is possible that the actual fee can be decreased below $F$ depending on the final mass

# Implementation details

### Mempool and P2P rule
As a first step, the storage mass calculation can be applied on the mempool level. Concretely, when building a new block template the node will compute the transaction mass using the suggested [formula](#combining-storage-mass-with-existing-mass). This will replace the currently implemented patch immediately with no need for an hardfork. However a long-term solution cannot rely on the goodwill of miners and so eventually the new mass calculation must be enforced via consensus validation.   

### Consensus (hardfork)
Here we shortly discuss the subtleties of implementing storage mass on the consensus level.

**Background** In Kaspa, block validation is divided into several parts: header validation, block validation and UTXO validation. Both header and block validation are mandatory in order for the block to be considered valid, however full UTXO validation (e.g., double-spend, signature validation, etc.) is done only during UTXO validation of chain block candidates (which can be this block or other blocks merging it).  

**Challenge** Unlike the current `compute_mass` which can be computed from the transaction structure in isolation (i.e., from the standalone transaction fields without further contextual information), the storage mass requires knowing the exact input values, which are only available with full UTXO context. This introduces a tension since on the one hand we would like to enforce storage mass block-limits as part of block-validity, while on the other hand this information is only available on the transaction level and only during the later phase of UTXO validation. 

**Solution** We adapt an idea already implemented for `sig_op_count`. An additional field should be added to the transaction object named `mass`. This field acts as a commitment for the total mass value of this transaction (including, of course, the storage mass). During block validation, the committed mass of all transactions in the block is summed and verified not to pass the block limits. During transaction validation (with UTXO context), the mass calculation is verified and the transaction is rejected if the committed mass is different than the expected mass. This field need not be filled by the wallets but is required to be set by the mining node during block template building. We emphasize that this new field only needs to be hashed when computing the transaction *hash* which is necessary for asserting deterministic transaction inclusion in the block (via the Merkle root of transaction hashes), but can be ignored when computing the transaction *id*. This is crucial, since unlike the hash which is only used by miners and by the node, changes in id calculation would require software updates throughout the Kaspa ecosystem. 

*Important note:* Once applied to consensus, miners must update their Grpc interface to a version which includes the new transaction field. Otherwise submitted blocks will hash incorrectly and wil be missing mandatory information.    

### Calculation accuracy
Like any consensus component, storage mass calculation must use only integers and cannot rely of floating-point arithmetics. Regarding the storage formula, this means that the constant $C$ must be computed within each fraction, otherwise the loss of precision will render the calculation useless.

### Current status
This proposal is already implemented by the Kaspa on Rust codebase ([PR](https://github.com/kaspanet/rusty-kaspa/pull/379)). Currently applied on the mempool level for all networks (mainnet, testnet 10, testnet 11). It is also implemented on the consensus level, but only activated for testnet 11 (TN11). The current implementation however is slightly different. Particularly, it sums the storage mass with the compute mass instead of using max, and it also does not implement the relaxed formula. The implementation will be updated shortly to reflect this final proposal. In order to avoid code clutter and multiple versions we suggest hardforking or restarting TN11 with the fixed rules. 

# References
[1] “A very dusty yom-kippur” https://medium.com/@shai.wyborski/a-very-dusty-yom-kippur-dust-attack-post-mortem-faa11804e37

[2] Kaspad go-lang dust patch: https://github.com/kaspanet/kaspad/pull/2244

[3] Unpublished paper on state growth regulation in permissionless systems, this reference will be updated once the paper is published online.
