```
  KIP: 9
  Layer: Mempool, P2P, Consensus
  Title: Extended mass formula for dust prevention
  Authors: Michael Sutton <msutton@cs.huji.ac.il>
           Ori Newman <orinewman1@gmail.com>
           Shai Wyborski <shai.wyborski@mail.huji.ac.il>
           Yonatan Sompolinsky
  Status: proposed, implemented in testnet 11 ([PR](https://github.com/kaspanet/rusty-kaspa/pull/379))
```

# Motivation
A few months back, the Kaspa network has faced a dust attack which exploited the high block-DAG capacity in order to increase the storage required for a full node (for a detailed account of this attack on Kaspa see [1]). A mempool patch [2] was applied to counter the attack by aggressively throttling transactions with more outputs than inputs. However, this patch did not properly address the quality-of-service (QoS) required for ordinary users making ordinary transactions, which often might contain excessive outputs (e.g. due to having a *change* output). Essentially, the patch harmed the scalability and throughput of the network by only allowing a single such transaction in each block. In this document we propose a comprehensive approach that balances the ostensibly contradictory objectives of preventing storage bloat without affecting the QoS.

Our proposal is based on a research paper written by (some of) the authors of this document [3]. A draft of this paper with full analysis and proofs supporting the claims brought here exists but isn't published yet (as of writing this document). In this document we will focus on the concrete formula suggested and its practical implications, both on security and usability.  

# Proposal
Blocks in the Kaspa block-DAG have a mass limit of 500,000. The mass of a block is the sum of the mass of all transactions it contains. In the current transaction mass formula, different types of data have different mass costs. For instance, signatures have a relatively high mass per byte compared with other data since verifying them is computationally expansive. However, current costs mostly address temporal usage of resources such as computation and short-term transaction storage (since transactions are eventually pruned), but fail to address the long-term effect on state storage, i.e., the direct or indirect consequences of a transaction on the number of entries in the UTXO set. 

Identifying this effect *locally* is no easy task -- for instance, a transaction can have 2 inputs and 2 unevenly distributed outputs (1 being “dust”), thus seemingly not increasing the size of the UTXO set, however the UTXO set now has an entry with hardly no intrinsic value, while the other large entry can be used for further state fragmentation in the future. At the same time, charging high costs per transaction by observing only the locally-visible increase in state size cannot capture the *global* structure of an ongoing attack and inevitably ends with a tradeoff that either harms everyday users or does not sufficiently prevent the attack. 

### A balanced cost function
Assume a transaction is composed (amongst other fields) from a set of input values $I$ and a set of output values $O$. We propose to add an additional mass component called the `storage_mass` computed in the following way: 
$$\text{storage mass}(tx) = \left(\sum_{out.val  \in  O} \frac{C}{out.val} - \frac{C\cdot|I|^2}{\sum_{in.val \in I} in.val}\right)^+;$$ 
where $C$ is a constant controlling the correlation of inverse KAS value to mass units and $(\cdot)^+$ is a shorthand for $max(\cdot, \text{ } 0)$. 

A more concise representation of the same formula can be given using the harmonic and arithmetic means ($H, A$ respectively):
$$\text{storage mass}(tx) = C\left(\frac{|O|}{H(O)} - \frac{|I|}{A(I)}\right)^+$$

In essence, the formula is sensitive to the distribution of output values (smoothly penalizing smaller and smaller entries), while balancing this by taking into account the size and total value of the input values. As proven in [3], the crucial meaning of this formula is that the accumulated `storage_mass` required for executing a set of transactions is now lower bounded by a quadratic function of the global state growth it caused. More formally, assume $G$ is a DAG of transactions resulting in $growth(G)$ UTXO-set growth, and denote $budget(G)$ to be the overall value of initial UTXO entries consumed by $G$, then:
$$\text{storage mass}(G) \ge \frac{C\cdot growth^2(G)}{budget(G)}$$

Below we will explain the meaning of this bound using concrete numbers.

### Combining storage mass with current mass formula
For clarity, let us name the current mass calculation already implemented in Kaspa as `compute_mass`. Both quantities, storage and compute masses, represent independent resources, thus we suggest the combined mass calculation to be the maximum over both and not their sum:
$$\text{mass}(tx) = max\left(\text{compute mass}(tx) , \text{ storage mass}(tx)\right)$$ 

### Relaxed storage mass formula
As shown in [3], the storage formula can be relaxed in the special case of 2:2 transactions (2 inputs and 2 outputs). That is, if $|O| \le |I| \le 2$, then:
$$\text{storage mass}^*(tx) = C\left(\frac{|O|}{H(O)} - \frac{|I|}{H(I)}\right)^+$$
The importance of this exception will be explained below when discussing wallet functionality.  

# Analysis of dust attack costs and regulation of UTXO set growth
To gain some quantitative understanding of the implications of the quadratic growth bound, let us use some concrete numbers. All Kaspa units we will use are in dwork units which are the smallest unit possible in Kaspa (currently referenced in code as “sompi”). A single `KAS` is equal $10^8$ dworks. We set the storage mass constant to $C = 10^{12}$. Consider an attacker who wants to increase the storage requirements by one gigabyte. For that, they would have to create 20 million, or $2 \cdot 10^7$ new UTXO entries. The trade-off the attacker faces is illustrated via the following two edge-cases:

- **Fixed budget**  The attacker wishes to minimize the budget of the attack and uses overall 20,000 `KAS`. According to the bound, this will incur overall storage mass of at least $C\cdot growth^2/budget = (10^{12}\cdot 4 \cdot 10^{14})/(2 \cdot 10^4 \cdot 10^8) = 2 \cdot 10^{14}$. This would require fully occupying 400 million blocks, which would take about a year and a half in 10BPS, assuming the attacker uses 100% of the network throughput and the fees are negligible.

- **Fixed growth rate** The attacker wishes to increase the storage by a whole GB within a single day (again, assuming the attacker is given the entire network throughput for
negligible fees). Reshaping in 10BPS, the network has a throughput of a bit over $4\cdot 10^{11}$ grams per day. Reshaping the bound we get $budget \ge C \cdot growth^2/\text{mass}$. Substituting $C = 10^{12}$, $growth = 2 \cdot 10^7$ and $\text{mass} = 4\cdot 10^{11}$ we get that the required budget is at least $10^{15}/4$ dworks, which is 2.5 million `KAS`. 

Overall the attack either takes a very long time, or requires significant budget to be locked within the “abused” storage.  

We can also use the bound to provide an absolute worst-case upper bound on the ***organic*** growth of the UTXO set. Consider an attacker with most of the supply, say $20$ billion Kaspa. With $C=10^{12}$ and 10BPS one can compute that an attack that lasts $d$ days will increase the storage by at most $460\sqrt{d}$ gigabytes. A one-day-long attack cannot increase the storage by more than one terabyte, a one-year-long attack is limited to $10$ terabytes, and a ten-year-long attack will create storage of at most $25$ terabytes. In practice we expect much smaller numbers, since most supply on the network will not be applied to maximally increasing the UTXO set. Yet, it is reassuring that even in a scenario worse than technically possible the storage growth rate is rather mild, considering that the maximal possible size of the UTXO set (assuming the entire supply is fragmented into outputs worth 10,000 dworks) is about 25 *peta*bytes.

# Quality of service and wallet consequences

## Ordinary wallet transactions

## Compounding transactions

## Exchanges and pools

## Micropayments

# Implementation details

## Mempool and P2P rule

## Consensus (hardfork)

## Calculation accuracy

# References
[1] “A very dusty yom-kippur” https://medium.com/@shai.wyborski/a-very-dusty-yom-kippur-dust-attack-post-mortem-faa11804e37

[2] Kaspad go-lang dust patch: https://github.com/kaspanet/kaspad/pull/2244

[3] Unpublished paper on regulating state growth in permissionless systems, this reference will be updated once the paper is published online.
